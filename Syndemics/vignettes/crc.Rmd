---
title: "Running the CRC"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Running the CRC}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Capture Recapture Estimation

Capture recapture (CRC) estimation derives from ecological studies where the entire population may not be observed at one time. However, by taking different estimates over time we can form an educated guess about the size of $N$. The nuance in this case, is the formation of 'multi-systems estimation' as an approach to the CRC, where instead of gathering information over time, we gather information which is spatially linked, allowing us to build a guess to the size of $N$ from longitudinally linked data.

## What is CRC ?
In the backend, CRC is really just running a stepwise negative binomial or poisson linear regression using these linked database counts as covariables. In the current implementation, CRC produces an estimate given a single year of data (within a given subgroup). What this means is, given data of OUD Origin (derived from the PHD), you must loop through the years to derive the $N$ for that year. For subgroup analysis you must loop through both year AND stratification.

## Some Issues
As we stratify further and further, we begin to see a lot of suppression - where the PHD mandates we remove the counts due to danger of identification. Because this mandate affects counts between 1:10, we perturb the data iteratively and build confidence intervals around our estimates.

# Non-stratified

```{r non-stratified, eval=FALSE}

## Initialising the Libraries
library(dplyr)
library(Syndemics)
library(doParallel)
library(readr)

## Loading non-stratified OUD_Origin data
#data <- readr::read_csv("OUD_Origin_path.csv") 

results <- list()
unique_years <- unique(data$year)
n_cores <- detectCores() - 1

registerDoParallel(n_cores)

for (i in unique_years) {
  
  estimates <- foreach(j = 1:1000, .combine = 'rbind', .packages = c("dplyr", "Syndemics")) %dopar% {
    set.seed(j)
    
    input <- data %>% 
      mutate(N_ID = ifelse(N_ID == -1, round(runif(nrow(.), 1, 10)), N_ID)) %>%
      filter(year == i) %>% 
      distinct()
    
    Syndemics::crc(
      input,
      "N_ID",
      c("Casemix", "APCD", "BSAS", "PMP", "Matris", "Death"),
      formula.selection = "stepwise",
      method = "poisson",
      opts.stepwise = list(direction = "forward", verbose = FALSE)
    )$estimate
  }
  
  crcMean  <- mean(estimates)
  crcMin   <- min(estimates)
  crcMax   <- max(estimates)
  SE_estimate   <- sd(estimates)
  estimate.LCI  <- crcMean - 1.96 * SE_estimate
  estimate.UCI  <- crcMean + 1.96 * SE_estimate
  
  known <- data %>%
    filter(year == i & N_ID != -1) %>%
    summarise(known = sum(N_ID)) %>%
    pull(known)
  print(known)
  
  est    <- crcMean + known
  estMin <- crcMin  + known
  estMax <- crcMax  + known
  total.LCI    <- est - 1.96 * SE_estimate
  total.UCI  <- est + 1.96 * SE_estimate
  
  results[[as.character(i)]] <- data.frame(
    Year          = i,
    Known         = known,
    Estimated     = crcMean,
    SE_Estimated  = SE_estimate,
    
    LCI_Estimated = estimate.LCI,
    UCI_Estimated = estimate.UCI,
    
    
    CRCMin       = estMin,
    CRCMax       = estMax,
    
    CRC_Total    = est,
    LCI_Total    = total.LCI,
    UCI_Total    = total.UCI

  )
}

stopImplicitCluster()

# Bind rows into final output
overall_output <- bind_rows(results)

# Export to CSV
write_csv(overall_output, "CRCtotal.csv")
```

# Stratified
##Note: For Age, we only use the data stratified according to the groups starting
 at 20 years of age

```{r stratified, eval=FALSE}

## Initialising the Libraries
library(dplyr)
library(Syndemics)
library(doParallel)
library(readr)

## Reading the Origin Data Stratified by Race, Age and Sex
race_data <- readr::read_csv("OUDOrigin_race_path.csv")
age_data <- readr::read_csv("OUDOrigin_age_twenty_path.csv")
sex_data <- readr::read_csv("OUDOrigin_sex_path.csv")

## Reading the Crosswalks
race_xwalk <- readr::read_csv("RESPOND Crosswalk_race_path.csv")
age_xwalk <- readr::read_csv("RESPOND Crosswalk_age_twenty_path.csv")
sex_xwalk <- readr::read_csv("RESPOND Crosswalk_sex_path.csv")


## Defining the subgroups for each Data Set
race_subgroup <- unique(race_data$final_re) 
sex_subgroup <- unique(sex_data$final_sex)

## Initializing the Variables for the nested for loop

race_results <- list()
age_results <- list()
sex_results <- list()

race_output_list <- list()
age_output_list <- list()
sex_output_list <- list()

race_unique_years <- unique(race_data$year)
age_unique_years <- unique(age_data$year)
sex_unique_years <- unique(sex_data$year)

n_cores <- detectCores() - 1

## Running for Race ###################################################################################################

registerDoParallel(n_cores)
for (s in race_subgroup) {
  for(i in race_unique_years) {
    race_estimates <- foreach(j = 1:1000, .combine = 'rbind', .packages = c("dplyr", "Syndemics")) %dopar% {
      set.seed(j)
      
      race_output <- race_data %>% 
        mutate(N_ID = ifelse(N_ID == -1, round(runif(nrow(.), 1, 10)), N_ID)) %>%
        filter(year == i & final_re == s) %>% 
        unique()
      
      Syndemics::crc(race_output, "N_ID", c("Casemix", "APCD", "BSAS", "PMP", "Matris", "Death"),
                     formula.selection = "stepwise", method = "poisson", 
                     opts.stepwise = list(direction = "forward",
                                         verbose = FALSE))$estimate
    } 

    # Calculate summary stats from CRC estimates
    crcMean <- mean(race_estimates)
    crcMin  <- min(race_estimates)
    crcMax  <- max(race_estimates)
    SE_estimate   <- sd(race_estimates)
    estimate.LCI  <- crcMean - 1.96 * SE_estimate
    estimate.UCI  <- crcMean + 1.96 * SE_estimate

    # Get known sum for that race-year
    known <- race_data %>%
      filter(year == i & final_re == s) %>%
      filter(N_ID != -1) %>%
      summarise(known = sum(N_ID)) %>%
      pull(known)
    print(known)

    # Add known to CRC estimates
    est       <- crcMean + known
    estMin    <- crcMin  + known
    estMax    <- crcMax  + known
    total.LCI <- est - 1.96 * SE_estimate
    total.UCI <- est + 1.96 * SE_estimate
  
    

    race_results[[as.character(i)]] <- data.frame(
    Race          = s,
    Year          = i,
    Known         = known,
    Estimated     = crcMean,
    SE_Estimated  = SE_estimate,
    
    LCI_Estimated = estimate.LCI,
    UCI_Estimated = estimate.UCI,
    
    
    CRCMin       = estMin,
    CRCMax       = estMax,
    
    CRC_Total    = est,
    LCI_Total    = total.LCI,
    UCI_Total    = total.UCI
  
 )
  }

  race_output_list[[as.character(s)]] <- bind_rows(race_results)
}

stopImplicitCluster()

## Binding the Output
race_output <- bind_rows(race_output_list)

## Arranging the Columns by Year and Race
race_output <- race_output %>% arrange(Year,Race)

## Joining the Labelled Categories for Race from race_xwalk
race_output$Race <- as.character(race_output$Race)

## Arranging the columns of Output Uniformly for all stratified results
race_output <- race_output %>% 
            left_join(race_xwalk, by=c("Race" = "final_re")) %>% 
            select(Year, race, Known, Estimated, SE_Estimated, LCI_Estimated, UCI_Estimated, CRCMin, CRCMax, CRC_Total, LCI_Total, UCI_Total)


## Export to CSV
readr::write_csv(race_output, "race_output.csv")


## Running for Age.  ###################################################################################################
registerDoParallel(n_cores)

age_output_list <- list()

for (s in age_subgroup) {
  age_results <- list()
  
  for (i in age_unique_years) {
    
    age_estimates <- foreach(j = 1:1000, .combine = 'rbind', .packages = c("dplyr", "Syndemics")) %dopar% {
      set.seed(j)
      
      age_input <- age_data %>%
        mutate(N_ID = ifelse(N_ID == -1, round(runif(nrow(.), 1, 10)), N_ID)) %>%
        filter(year == i & age_grp_twenty == s) %>%
        distinct()

      Syndemics::crc(
        age_input,
        "N_ID",
        c("Casemix", "APCD", "BSAS", "PMP", "Matris", "Death"),
        formula.selection = "stepwise",
        method = "poisson",
        opts.stepwise = list(direction = "forward", verbose = FALSE)
      )$estimate
    }

    crcMean <- mean(age_estimates)
    crcMin  <- min(age_estimates)
    crcMax  <- max(age_estimates)
    SE_estimate   <- sd(age_estimates)
    estimate.LCI  <- crcMean - 1.96 * SE_estimate
    estimate.UCI  <- crcMean + 1.96 * SE_estimate

    known <- age_data %>%
      filter(year == i & age_grp_twenty == s & N_ID != -1) %>%
      summarise(known = sum(N_ID)) %>%
      pull(known)
    print(known)

    est    <- crcMean + known
    estMin <- crcMin  + known
    estMax <- crcMax  + known
    total.LCI <- est - 1.96 * SE_estimate
    total.UCI <- est + 1.96 * SE_estimate
   

    age_results[[as.character(i)]] <- data.frame(
      Age    = s,
      Year     = i,
      Known    = known,
      Estimated     = crcMean,
      SE_Estimated  = SE_estimate,
    
      LCI_Estimated = estimate.LCI,
      UCI_Estimated = estimate.UCI,
    
     
      CRCMin       = estMin,
      CRCMax       = estMax,
    
      CRC_Total    = est,
      LCI_Total    = total.LCI,
      UCI_Total    = total.UCI
    )
  }

  age_output_list[[as.character(s)]] <- bind_rows(age_results)
}

stopImplicitCluster()

## Binding the output
age_output <- bind_rows(age_output_list)

## Arranging the Columns by Year and Age
age_output <- age_output %>% arrange(Year,Age)

## Joining the Labelled Categories for Age from age_xwalk
age_output$Age <- as.character(age_output$Age)

## Arranging the columns of Output Uniformly for all stratified results
age_output <- age_output %>% 
              left_join(age_xwalk, by=c('Age'='age_grp_twenty')) %>% 
              select(Year, age_twenty, Known, Estimated, SE_Estimated, LCI_Estimated, UCI_Estimated, CRCMin, CRCMax, CRC_Total, LCI_Total, UCI_Total)

## Export to CSV
readr::write_csv(age_output, "age_output.csv")


## Running for Sex ###################################################################################################
  
registerDoParallel(n_cores)

sex_output_list <- list()

for (s in sex_subgroup) {
  sex_results <- list()
  
  for (i in sex_unique_years) {
    
    sex_estimates <- foreach(j = 1:1000, .combine = 'rbind', .packages = c("dplyr", "Syndemics")) %dopar% {
      set.seed(j)
      
      sex_input <- sex_data %>%
        mutate(N_ID = ifelse(N_ID == -1, round(runif(nrow(.), 1, 10)), N_ID)) %>%
        filter(year == i & final_sex == s) %>%
        distinct()

      Syndemics::crc(
        sex_input,
        "N_ID",
        c("Casemix", "APCD", "BSAS", "PMP", "Matris", "Death"),
        formula.selection = "stepwise",
        method = "poisson",
        opts.stepwise = list(direction = "forward", verbose = FALSE)
      )$estimate
    }

    crcMean <- mean(sex_estimates)
    crcMin  <- min(sex_estimates)
    crcMax  <- max(sex_estimates)
    SE_estimate   <- sd(sex_estimates)
    estimate.LCI  <- crcMean - 1.96 * SE_estimate
    estimate.UCI  <- crcMean + 1.96 * SE_estimate 

    known <- sex_data %>%
      filter(year == i & final_sex == s & N_ID != -1) %>%
      summarise(known = sum(N_ID)) %>%
      pull(known)
    print(known)

    est    <- crcMean + known
    estMin <- crcMin  + known
    estMax <- crcMax  + known
    total.LCI <- est - 1.96 * SE_estimate
    total.UCI <- est + 1.96 * SE_estimate

    sex_results[[as.character(i)]] <- data.frame(
      Sex      = s,
      Year     = i,
      Known    = known,
      Estimated     = crcMean,
      SE_Estimated  = SE_estimate,
    
      LCI_Estimated = estimate.LCI,
      UCI_Estimated = estimate.UCI,
     
      CRCMin       = estMin,
      CRCMax       = estMax,
    
      CRC_Total    = est,
      LCI_Total    = total.LCI,
      UCI_Total    = total.UCI
    )
  }
  sex_output_list[[as.character(s)]] <- bind_rows(sex_results)
}
stopImplicitCluster()

## Binding the output
sex_output <- bind_rows(sex_output_list)

## Arranging the output by Year and Sex
sex_output <- sex_output %>% arrange(Year,Sex)

## Joining the Labelled Categories for Sex from sex_xwalk
sex_output$Sex <- as.character(sex_output$Sex)

## Arranging the columns of Output Uniformly for all stratified results
sex_output <- sex_output %>% 
              left_join(sex_xwalk, by = c("Sex" = "final_sex")) %>% 
              select(Year, sex, Known, Estimated, SE_Estimated, LCI_Estimated, UCI_Estimated, CRCMin, CRCMax, CRC_Total, LCI_Total, UCI_Total)

## Export to CSV
readr::write_csv(sex_output, "sex_output.csv")
 
```
